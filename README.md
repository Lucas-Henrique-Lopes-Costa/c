# Introdução a Algoritmos

# *Componentes de algoritmos. Variáveis. Sistema de numeração. Tipos de dados. Declaração de Variáveis.*

<details>
<summary> Quais são os elementos básicos de um algoritmo?</summary>
    Os elementos básicos de um algoritmo incluem variáveis, operadores, expressões, estruturas de controle e comentários.
</details>
<br>

<details>
<summary>Defina dados.</summary>
    Dados são informações que podem ser processadas por um programa de computador.
</details>
<br>

<details>
<summary>Quais as principais estruturas que podem compor um algoritmo?</summary>
    As principais estruturas que podem compor um algoritmo são sequência, seleção (como if/else) e repetição (como while/for).
</details>
<br>

<details>
<summary>O que são operadores?</summary>
    Operadores são símbolos que representam uma operação a ser realizada em um ou mais operandos.
</details>
<br>

<details>
<summary>Qual a função dos comentários em um código?</summary>
    A função dos comentários em um código é fornecer explicações e informações adicionais para ajudar os desenvolvedores a entender o que o código está fazendo.
</details>
<br>

<details>
<summary>Quais as outras estratégias para aumentar a legibilidade de um código?</summary>
    Outras estratégias para aumentar a legibilidade de um código incluem usar nomes descritivos para variáveis e funções, manter o código bem organizado e seguir convenções de estilo de codificação.
</details>
<br>

<details>
<summary>O que são variáveis?</summary>
    Variáveis são espaços de armazenamento na memória do computador que podem conter valores.
</details>
<br>

<details>
<summary>Qual a importância do tipo de dado usado em um programa?</summary>
    O tipo de dado usado em um programa é importante porque determina como os dados serão armazenados na memória e como serão tratados pelo programa.
</details>
<br>

<details>
<summary>O que são sistemas numéricos</summary>
    Sistemas numéricos são sistemas de representação de números. Os sistemas numéricos comuns incluem decimal, binário, octal e hexadecimal.
</details>
<br>

<details>
<summary>Qual(is) é(são) o(s) sistema(s) numérico(s) utilizado(s) pelo(s) computador(es)?</summary>
    Os computadores geralmente utilizam os sistemas numéricos binário e hexadecimal.
</details>
<br>

<details>
<summary>É possível representar um dado, originalmente representado no sistema numérico decimal, em outro sistema numérico?</summary>
    Sim, é possível representar um dado originalmente representado no sistema numérico decimal em outro sistema numérico, como binário, octal ou hexadecimal.
</details>
<br>

<details>
<summary>É possível realizar operações aritméticas em dados representados em outro sistema numérico que não seja o decimal?</summary>
    Sim, é possível realizar operações aritméticas em dados representados em sistemas numéricos diferentes do decimal, desde que os operadores sejam aplicados corretamente.
</details>
<br>

<details>
<summary>O que pode interferir nos tipos de dados disponibilizados por uma linguagem de programação?</summary>
    Os tipos de dados disponíveis em uma linguagem de programação podem ser limitados por fatores como a arquitetura do computador, as bibliotecas disponíveis e as escolhas de design da linguagem.
</details>
<br>

<details>
<summary>Descreva dois tipos de dados fundamentais indicando suas principais características.</summary>
    Dois tipos de dados fundamentais são inteiros e pontos flutuantes. Inteiros são números inteiros (sem parte fracionária) e pontos flutuantes são números reais (com parte fracionária).
</details>
<br>

<details>
<summary>Descreva dois tipos de dados fundamentais, diferentes daqueles apresentados na questão anterior, indicando suas principais características.</summary>
    Dois outros tipos de dados fundamentais são caracteres e booleanos. Caracteres representam símbolos individuais (como letras e números) e booleanos representam valores verdadeiros ou falsos.
</details>
<br>

<details>
<summary>O que são ponteiros?</summary>
    Ponteiros são variáveis que armazenam endereços de memória em vez de valores.
</details>
<br>

<details>
<summary>Quais as informações mínimas necessárias para a declaração de uma variável?</summary>
    Para declarar uma variável, é necessário fornecer seu tipo e um nome descritivo.
</details>
<br>

<details>
<summary>Como inicializar ou alterar o valor de uma variável?</summary>
    O valor de uma variável pode ser inicializado ou alterado atribuindo um valor a ela usando o operador de atribuição (=).
</details>
<br>

<details>
<summary>O que é uma constante e qual sua importância?</summary>
    Uma constante é um valor que não pode ser alterado durante a execução do programa. Sua importância está na garantia da consistência dos dados.
</details>
<br>

<details>
<summary>Qual a diferença entre tipificação forte e tipificação fraca?</summary>
    Tipificação forte significa que as variáveis têm um tipo de dado definido e não podem ser usadas de maneira incompatível com esse tipo. Tipificação fraca significa que as variáveis podem ser usadas de maneira mais flexível, com coerção automática de tipo, por exemplo.
</details>
<br>

<details>
<summary>O que são identificadores de variáveis? Descreva um cuidado que se deve ter ao definir um identificador.</summary>
    Identificadores de variáveis são nomes que representam variáveis. É importante escolher identificadores descritivos e seguir as convenções de nomenclatura da linguagem de programação.
</details>
<br>

<details>
<summary>Que cuidados devem ser tomados ao se utilizar ponteiros?</summary>
    Ao utilizar ponteiros, é importante tomar cuidado para garantir que eles apontem
</details>
<br>

# *Operadores, Entrada e Saída de dados, Estrutura Sequencial. Arquivos.*

<details>
<summary>Como é feita a associação de um valor a uma variável?</summary>
    A associação de um valor a uma variável é feita através do operador de atribuição "=" em linguagens de programação. A variável é o identificador que representa um espaço na memória do computador onde o valor será armazenado.
</details>
<br>

<details>
<summary>O que pode ser usado à direita de um operador de atribuição?</summary>
    À direita do operador de atribuição podem ser usados constantes, variáveis, expressões ou funções que retornem um valor compatível com o tipo da variável.
</details>
<br>

<details>
<summary>Descreva dois cuidados a serem tomados para que uma atribuição possa ser realizada.</summary>
    Dois cuidados importantes a serem tomados ao realizar uma atribuição são: garantir que a variável esteja declarada e inicializada antes de ser utilizada, e verificar se o tipo do valor a ser atribuído é compatível com o tipo da variável.
</details>
<br>

<details>
<summary>O que acontece quando um valor em ponto flutuante é associado a uma variável do tipo inteiro?</summary>
    Quando um valor em ponto flutuante é associado a uma variável do tipo inteiro, o valor é truncado para o próximo inteiro mais próximo. Por exemplo, 3.7 seria truncado para 3.
</details>
<br>

<details>
<summary>O que acontece quando um valor inteiro é associado a uma variável do tipo float?</summary>
    Quando um valor inteiro é associado a uma variável do tipo float, o valor é convertido em um ponto flutuante, mantendo sua precisão. Por exemplo, 3 seria convertido em 3.0.
</details>
<br>

<details>
<summary>O que acontece quando um valor qualquer é associado a uma variável já inicializada?</summary>
    Quando um valor é associado a uma variável já inicializada, o valor anterior é substituído pelo novo valor.
</details>
<br>

<details>
<summary>O que acontece quando uma variável é utilizada em ambos os lados do operador de atribuição?</summary>
    Quando uma variável é utilizada em ambos os lados do operador de atribuição, o resultado pode ser imprevisível, dependendo do contexto em que é utilizado. É importante evitar esse tipo de operação.
</details>
<br>

<details>
<summary>Quais são os operadores aritméticos? Qual a precedência entre eles?</summary>
    Os operadores aritméticos são: + (adição), - (subtração), * (multiplicação), / (divisão) e % (resto da divisão). A precedência segue da matemática.
</details>
<br>

<details>
<summary>Qual a importância da observação da precedência entre operadores?</summary>
    A observação da precedência entre operadores é importante para garantir que as operações sejam realizadas na ordem correta e o resultado seja o esperado.
</details>
<br>

<details>
<summary>Qual o valor de X resultante da operação X = 7 / 2 ?</summary>
    O valor resultante de X = 7 / 2 seria 3.
</details>
<br>

<details>
<summary>O que precisa ser feito para garantir que o valor correto seja obtido?</summary>
    Para garantir que o valor correto seja obtido, pode utilizar um casting para forçar a conversão do resultado para o tipo desejado. Por exemplo: X = (float) (7 / 2) resultaria em X = 3.5.</summary>
    Ou pode utilizar 7 / 2.0
</details>
<br>

<details>
<summary>Como pode ser feita a combinação entre operadores aritméticos e o operador de atribuição?</summary>
    A combinação entre operadores aritméticos e o operador de atribuição é realizada através de operadores compostos, como +=,*= e /=. Por exemplo, X += 5 é equivalente a X = X + 5.
</details>
<br>

<details>
<summary>Cite os meios através dos quais um programa pode receber dados a serem processados.</summary>
    Um programa pode receber dados a serem processados através de entrada padrão (teclado), arquivos, dispositivos de rede ou outros dispositivos de entrada específicos.
</details>
<br>

<details>
<summary>Cite os meios através dos quais um programa pode apresentar os dados resultantes.</summary>
    Um programa pode apresentar os dados resultantes através de saída padrão (tela), arquivos, dispositivos de rede ou outros dispositivos de saída específicos.
</details>
<br>

<details>
<summary>Qual o conteúdo da biblioteca cmath?</summary>
    A biblioteca cmath é utilizada para realizar operações matemáticas mais avançadas, como funções trigonométricas e logarítmicas.
</details>
<br>

<details>
<summary>Cite uma vantagem do uso de arquivos.</summary>
    Uma vantagem do uso de arquivos é a possibilidade de armazenar dados permanentemente em um dispositivo de armazenamento secundário, como um disco rígido, mesmo após o término da execução do programa.
</details>
<br>

<details>
<summary>Qual biblioteca deve ser incluída para manipulação de arquivos?</summary>
    A biblioteca para manipulação de arquivos em C++ é a fstream.
</details>
<br>

<details>
<summary>O que faz a instrução ofstream arquivo ("musica.txt"); ?</summary>
    A instrução ofstream arquivo ("musica.txt") cria um objeto do tipo ofstream (output file stream
</details>
<br>

<details>
<summary>O que faz a instrução ifstream arquivo ("musica.txt"); ?</summary>
  A instrução ifstream arquivo ("musica.txt"); cria um objeto do tipo ifstream (input file stream) que permite a leitura de um arquivo de texto chamado "musica.txt". Ou seja, essa instrução abre o arquivo "musica.txt" para leitura e cria um objeto "arquivo" que pode ser usado para ler os dados armazenados no arquivo.
</details>
<br>

1. A diferença entre uma string e um vetor de caracteres está na forma como são tratados. Uma string é um tipo de dado especial em C/C++ que é tratado como uma sequência de caracteres terminada por um caractere nulo (\0). Um vetor de caracteres, por outro lado, é apenas uma sequência de caracteres sem nenhum tratamento especial.

2. As funções length(), size() e strlen() servem para obter o tamanho de uma string ou vetor de caracteres.
    A função length() é usada para obter o tamanho de uma string no C++, ela retorna o número de caracteres na string, excluindo o caractere nulo (\0).
    A função size() é usada para obter o tamanho de um vetor, ela retorna o número de elementos no vetor.
    A função strlen() é usada para obter o comprimento de uma string em C, ela retorna o número de caracteres na string, excluindo o caractere nulo (\0).
    
3. A função length() retorna um valor do tipo size_t, a função size() retorna um valor do tipo size_t e a função strlen() retorna um valor do tipo size_t.

4. A função getline() é utilizada para ler uma linha inteira de entrada, incluindo espaços em branco, e armazená-la em uma string. Ela é especialmente útil quando se deseja ler uma linha inteira de texto digitada pelo usuário.

5. A diferença no uso da função getline() com string e vetor de caracteres está na forma como os dados são armazenados. Quando usada com uma string (do tipo std::string), a função getline() armazena a linha lida diretamente na string. Já quando usada com um vetor de caracteres, é necessário fornecer o tamanho máximo do vetor como parâmetro e a função armazena a linha lida no vetor, limitando o número de caracteres ao tamanho máximo especificado.

6. A função cin.ignore() é utilizada para descartar caracteres indesejados do buffer de entrada. Ela é comumente usada após a leitura de dados numéricos usando cin, para descartar caracteres extras (como espaços em branco, novas linhas) que possam interferir na próxima leitura.

7. Uma matriz em C/C++ é uma estrutura de dados bidimensional que consiste em uma coleção de elementos organizados em linhas e colunas.

8. Para declarar uma matriz em C/C++, você precisa especificar o tipo dos elementos da matriz e o tamanho das dimensões. A sintaxe geral é: tipo nome_da_matriz[linha][coluna];

9. Sim, é possível ter uma matriz de string em C/C++. Para isso, você precisa declarar uma matriz de ponteiros para char (ou seja, um vetor de strings) e alocar memória para cada string individualmente.

10. Exemplo de declaração e preenchimento de uma matriz 3x4 lendo os dados da entrada padrão:

```
#include <iostream>

int main() {
    int matriz[3][4];

    // Preenchendo a matriz com dados lidos da entrada padrão
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            std::cin >> matriz[i][j];
        }
    }

    // Imprimindo os dados da matriz
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            std::cout << matriz[i][j] << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}

```

11. Exemplo de declaração de uma matriz nxn e preenchimento com dados lidos do arquivo "entrada.txt":

```
#include <iostream>
#include <fstream>

int main() {
    int n;
    std::ifstream arquivo("entrada.txt");

    // Lendo o valor de n do arquivo
    arquivo >> n;

    int matriz[n][n];

    // Preenchendo a matriz com dados do arquivo
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            arquivo >> matriz[i][j];
        }
    }

    arquivo.close();

    // Imprimindo os dados da matriz
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cout << matriz[i][j] << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
```

12. Exemplo de código para imprimir os elementos da matriz pelas colunas:

```
#include <iostream>

int main() {
    int matriz[2][2] = {{3, 4}, {5, 6}};

    // Imprimindo os elementos da matriz pelas colunas
    for (int j = 0; j < 2; j++) {
        for (int i = 0; i < 2; i++) {
            std::cout << matriz[i][j] << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
```

13. Exemplo de código para imprimir o maior elemento da matriz:

```
#include <iostream>

int main() {
    int matriz[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    int maior = matriz[0][0];

    // Encontrando o maior elemento da matriz
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if (matriz[i][j] > maior) {
                maior = matriz[i][j];
            }
        }
    }

    std::cout << "Maior elemento da matriz: " << maior << std::endl;

    return 0;
}
```

14. Exemplo de código para imprimir a linha do menor elemento da matriz:

```
#include <iostream>

int main() {
    int matriz[3][3] = {{1, 2, 3}, {4, 0, 6}, {7, 8, 9}};
    int menor = matriz[0][0];
    int linhaMenor = 0;

    // Encontrando o menor elemento da matriz e a linha correspondente
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if (matriz[i][j] < menor) {
                menor = matriz[i][j];
                linhaMenor = i;
            }
        }
    }

    std::cout << "Linha do menor elemento da matriz: " << linhaMenor << std::endl;

    return 0;
}
```

15. Aqui está um exemplo de função em C++ que recebe uma matriz 4x4 como parâmetro e multiplica todos os elementos por 10:

```
#include <iostream>

void multiplyByTen(int matrix[4][4]) {
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            matrix[i][j] *= 10;
        }
    }
}

int main() {
    int matrix[4][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12},
        {13, 14, 15, 16}
    };

    multiplyByTen(matrix);

    // Imprime a matriz multiplicada por 10
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            std::cout << matrix[i][j] << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
```

A função multiplyByTen recebe uma matriz 4x4 como parâmetro e itera sobre cada elemento, multiplicando-o por 10.

16. Aqui está um exemplo de trecho de código que realiza a alocação dinâmica de uma matriz, preenche-a com dados da entrada padrão e, em seguida, desaloca a matriz:

```
#include <iostream>

int main() {
    int rows, columns;
    std::cout << "Informe o número de linhas: ";
    std::cin >> rows;
    std::cout << "Informe o número de colunas: ";
    std::cin >> columns;

    // Alocação dinâmica da matriz
    int** matrix = new int*[rows];
    for (int i = 0; i < rows; i++) {
        matrix[i] = new int[columns];
    }

    // Preenchimento da matriz com dados da entrada padrão
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < columns; j++) {
            std::cout << "Informe o elemento [" << i << "][" << j << "]: ";
            std::cin >> matrix[i][j];
        }
    }

    // Impressão da matriz
    std::cout << "Matriz informada:" << std::endl;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < columns; j++) {
            std::cout << matrix[i][j] << " ";
        }
        std::cout << std::endl;
    }

    // Desalocação da matriz
    for (int i = 0; i < rows; i++) {
        delete[] matrix[i];
    }
    delete[] matrix;

    return 0;
}
```

Nesse exemplo, o usuário informa o número de linhas e colunas da matriz. Em seguida, é feita a alocação dinâmica da matriz utilizando ponteiros. Os elementos são preenchidos com dados da entrada padrão e, por fim, a matriz é desalocada utilizando delete[].

17. Sim, é possível percorrer os índices de uma matriz usando o incremento de um ponteiro. Em C++, uma matriz é armazenada em memória como um bloco contíguo de elementos.

# Modularização e passagem de parâmetros

1. A modularização é o processo de dividir um programa em módulos independentes e interconectados. Cada módulo é responsável por uma tarefa específica e pode ser desenvolvido e mantido separadamente. Isso facilita a compreensão, o desenvolvimento e a manutenção do código.

2. Os tipos de retorno que um módulo pode ter são:
    Void: indica que o módulo não retorna nenhum valor.
    Tipos primitivos (como int, float, double, etc.): o módulo retorna um valor do tipo especificado.
    Objetos ou estruturas definidas pelo usuário: o módulo retorna um objeto ou uma estrutura personalizada.

3. O escopo de variáveis se refere à região do código em que uma variável é visível e pode ser acessada. Em C++, existem três principais escopos de variáveis:
    Escopo global: as variáveis declaradas fora de qualquer função ou bloco são globais e podem ser acessadas por todo o programa.
    Escopo local: as variáveis declaradas dentro de uma função ou bloco são locais e só podem ser acessadas dentro desse escopo específico.
    Escopo de bloco: as variáveis declaradas dentro de um bloco delimitado por chaves ({}) só podem ser acessadas dentro desse bloco.
    Uma variável local é declarada dentro de uma função ou bloco e só é visível e acessível dentro desse escopo específico. Ela é criada quando a função é chamada ou o bloco é executado e é destruída quando a função ou o bloco é encerrado.

4. Uma variável global é declarada fora de qualquer função ou bloco e pode ser acessada por todo o programa. Ela existe durante toda a execução do programa.
    Uma função é um bloco de código que realiza uma tarefa específica e pode retornar um valor. Ela pode receber parâmetros como entrada e retornar um resultado.

5. Uma função é um bloco de código que realiza uma tarefa específica e pode retornar um valor. Ela pode receber parâmetros como entrada e retornar um resultado.
    Um procedimento, também conhecido como sub-rotina, é um bloco de código que realiza uma tarefa específica, mas não retorna um valor. Ele também pode receber parâmetros como entrada, mas não possui um valor de retorno.

6. Parâmetros formais são as variáveis declaradas na definição de um subprograma (função ou procedimento) que são utilizadas para receber os valores passados como argumentos quando o subprograma é chamado. Eles são como "placeholders" para os valores reais que serão passados durante a chamada.

7. Parâmetros reais são os valores ou expressões passados como argumentos durante a chamada de um subprograma. Esses valores são atribuídos aos parâmetros formais correspondentes no momento da chamada.

8. A passagem de parâmetros é o mecanismo pelo qual os valores ou referências de variáveis são passados para um subprograma (como uma função ou procedimento) quando ele é chamado. Isso permite que os subprogramas utilizem os valores passados como argumentos para realizar suas operações.

9. No código fornecido, os seguintes passos ocorrem quando o subprograma "soma" é chamado:
    a) O programa principal solicita a entrada de dois valores inteiros (variáveis "a" e "b") do usuário.
    b) O programa principal chama o subprograma "soma" passando os valores de "a" e "b" como argumentos.
    c) O subprograma "soma" recebe os valores dos parâmetros "a" e "b" e os utiliza para realizar a operação de soma.
    d) O resultado da soma é retornado pelo subprograma "soma".
    e) O programa principal imprime o resultado retornado pelo subprograma "soma" usando a função "cout".

10.  comando return é utilizado para retornar um valor de um subprograma de volta para o ponto de chamada. Ele também pode ser usado para encerrar precocemente a execução de um subprograma.

11. Sim, um subprograma pode não ter retorno de valor. Nesse caso, ele é chamado de procedimento. Um procedimento realiza ações sem retornar um valor específico.

12. No C++, não é possível retornar várias informações diretamente pela instrução return. Para retornar múltiplos valores, podem ser usados ponteiros ou referências, ou uma estrutura de dados (como uma struct ou uma classe) pode ser definida para armazenar os valores a serem retornados.

13. 
    a) Sim, o trecho de código compila corretamente, desde que as bibliotecas necessárias sejam incluídas no código.
    b) O bloco "calcula" é uma função, pois possui um tipo de retorno definido (int).
    c) Se valor = 5, o valor impresso será 120. O programa calcula o fatorial de valor (5!) e retorna o resultado.

14. Subprograma "calcula" utilizando a estrutura do...while:

```
int calcula(int n) {
	int f = 1, c = 2;
	do {
		f *= c;
		c++;
	} while (c <= n);
	return f;
}
```

15. Subprograma para calcular o quociente inteiro de dois números sem usar a divisão (/) ou o operador resto (%):

```
int quocienteInteiro(int dividendo, int divisor) {
	int quociente = 0;
	while (dividendo >= divisor) {
		dividendo -= divisor;
		quociente++;
	}
	return quociente;
}
```

16. Subprograma para imprimir um triângulo de letras:

```
void imprimirTriangulo(int n) {
	char letra = 'a';
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= i; j++) {
			cout << letra << " ";
			letra++;
		}
		cout << endl;
		letra = 'a';
	}
}
```

17. A passagem de parâmetros por valor ocorre quando o valor de uma variável é copiado e passado como argumento para um subprograma. Qualquer alteração feita no valor do parâmetro dentro do subprograma não afetará a variável original. Exemplo:

```
void dobrarValor(int x) {
	x *= 2;
}

int main() {
	int num = 5;
	dobrarValor(num);
	cout << num;  // O valor impresso será 5, pois o valor de 'num' não foi alterado dentro do subprograma.
	return 0;
}
```

18. A passagem de parâmetros por referência ocorre quando o endereço de memória de uma variável é passado como argumento para um subprograma. Qualquer alteração feita no valor do parâmetro dentro do subprograma afetará diretamente a variável original. Exemplo:

```
void dobrarValor(int& x) {
	x *= 2;
}

int main() {
	int num = 5;
	dobrarValor(num);
	cout << num;  // O valor impresso será 10, pois o valor de 'num' foi alterado dentro do subprograma.
	return 0;
}
```

19. Função Maximo que retorna o maior número entre dois valores reais:

```
#include <iostream>

double Maximo(double a, double b) {
	return (a > b) ? a : b;
}

int main() {
	double num1, num2;
	std::cin >> num1 >> num2;
	std::cout << "Maior valor: " << Maximo(num1, num2) << std::endl;
	return 0;
}
```

20. Função para retornar o antecessor e sucessor de um número inteiro:

```
#include <iostream>

void antecessorSucessor(int num, int& antecessor, int& sucessor) {
	antecessor = num - 1;
	sucessor = num + 1;
}

int main() {
	int numero, antecessor, sucessor;
	std::cin >> numero;
	antecessorSucessor(numero, antecessor, sucessor);
	std::cout << "Antecessor: " << antecessor << std::endl;
	std::cout << "Número: " << numero << std::endl;
	std::cout << "Sucessor: " << sucessor << std::endl;
	return 0;
}
```

21. Função para verificar se um número inteiro é primo:

```
#include <iostream>

bool isPrimo(int num) {
	if (num < 2)
		return false;
	for (int i = 2; i * i <= num; i++) {
		if (num % i == 0)
			return false;
	}
	return true;
}

int main() {
	int numero;
	std::cin >> numero;
	if (isPrimo(numero))
		std::cout << "É primo" << std::endl;
	else
		std::cout << "Não é primo" << std::endl;
	return 0;
}
```

22. Função para calcular o somatório com base em um parâmetro 'n':

```
#include <iostream>

int somatorio(int n) {
	int resultado = 0;
	for (int i = 1; i <= n; i++) {
		resultado += i;
	}
	return resultado;
}

int main() {
	int numero;
	std::cin >> numero;
	int resultado = somatorio(numero);
	std::cout << "Resultado: " << resultado << std::endl;
	return 0;
}
```
